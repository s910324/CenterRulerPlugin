<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import os 
import pya
import math

from itertools import chain

class CenterRulerSetupDock(pya.QDockWidget):
    def __init__(self):
        super(CenterRulerSetupDock, self).__init__()
        self.ctrSetup = CenterRulerSetupWidget()
        self.setWidget (self.ctrSetup)
        self.setWindowTitle("Center Ruler")
        
    def setHostValue(self, host, rulerType, rulerStyle, snapRange, showCircumf):
        self.ctrSetup.setHostValue(host, rulerType, rulerStyle, snapRange, showCircumf)
        
class CenterRulerSetupWidget(pya.QWidget):
    def __init__(self):
        super(CenterRulerSetupWidget, self).__init__()
        self.host         = None
        self.rulerTypeLB  = pya.QLabel("Ruler Type:")
        self.rulerStyleLB = pya.QLabel("Ruler Style:")
        self.snpRngLB     = pya.QLabel("Snap Range:")
        self.showCircfLB  = pya.QLabel("Show Circumference:")
        self.snpRngSfxLB  = pya.QLabel("um")
        self.snpRngDSB    = pya.QDoubleSpinBox()
        self.rulerTypeCB  = pya.QComboBox()
        self.rulerStyleCB = pya.QComboBox()
        self.showCircfCB  = pya.QCheckBox ("")
        self.layout       = pya.QGridLayout()
        
        self.snpRngDSB.setRange (0.001, 10000)
        self.snpRngDSB.setDecimals (3)
        self.snpRngDSB.setSingleStep (1)
        self.snpRngDSB.setValue(1)  
        
        self.layout.addWidget(self.rulerTypeLB,  0, 0, 1, 1)
        self.layout.addWidget(self.rulerTypeCB,  0, 1, 1, 1)
        
        self.layout.addWidget(self.rulerStyleLB, 1, 0, 1, 1)
        self.layout.addWidget(self.rulerStyleCB, 1, 1, 1, 1)
        
        self.layout.addWidget(self.snpRngLB,     2, 0, 1, 1)
        self.layout.addWidget(self.snpRngDSB,    2, 1, 1, 1)
        self.layout.addWidget(self.snpRngSfxLB,  2, 2, 1, 1)
         
        self.layout.addWidget(self.showCircfLB,  3, 0, 1, 1)
        self.layout.addWidget(self.showCircfCB,  3, 1, 1, 1)
                       
        self.layout.setRowStretch(4, 1)
        self.setLayout(self.layout)
        
        self.snpRngDSB.valueChanged (lambda :self.updateHostValue())
        self.rulerTypeCB.currentIndexChanged (lambda :self.updateHostValue())
        self.rulerStyleCB.currentIndexChanged (lambda :self.updateHostValue())
        self.showCircfCB.stateChanged (lambda :self.updateHostValue())
        
        self.antOutline = {
            "Diagnal"    : pya.Annotation.OutlineDiag,
            "TriangleXY" : pya.Annotation.OutlineDiagXY,
            "TriangleYX" :	 pya.Annotation.OutlineDiagYX,
            "Box"        : pya.Annotation.OutlineBox,
            "XY"         : pya.Annotation.OutlineXY,
            "YX"         : pya.Annotation.OutlineYX,
        }
        
        self.antStyle = {
            "Plan line"          : pya.Annotation.StyleLine,
            "Ruler"              : pya.Annotation.StyleRuler,
            "Arrow at both ends" : pya.Annotation.StyleArrowBoth,
            "Arrow at end"       : pya.Annotation.StyleArrowEnd,
            "Arrow at start"     : pya.Annotation.StyleArrowStart,
            "Cross at both ends" : pya.Annotation.StyleCrossBoth,
            "Cross at end"       : pya.Annotation.StyleCrossEnd,
            "Cross at start"     : pya.Annotation.StyleCrossStart,
        }
        
        self.rulerTypeCB.addItems([key for key in self.antOutline])
        self.rulerStyleCB.addItems([key for key in self.antStyle])
        
    def setHostValue(self, host, rulerType, rulerStyle, snapRange, showCircumf):
        self.host = host
        
        for i, key in enumerate(self.antOutline):
            if self.antOutline[key] == rulerType:
                self.rulerTypeCB.setCurrentIndex(i)
            
        for i, key in enumerate(self.antStyle):
            if self.antStyle[key] == rulerStyle:
                self.rulerTypeCB.setCurrentIndex(i) 
                       
        self.snpRngDSB.setValue(snapRange)    
        self.showCircfCB.setCheckState( pya.Qt.CheckState.Checked if showCircumf else pya.Qt.CheckState.Unchecked )
    
    def updateHostValue(self): 
        if self.host: 
            self.host.searchSize   = self.snpRngDSB.value
            self.host.rulerOutline = self.antOutline[self.rulerTypeCB.currentText]
            self.host.rulerStyle   = self.antStyle[self.rulerStyleCB.currentText]
            self.host.showCircumf  = self.showCircfCB.isChecked() 
                     
    def hideEvent(self, event):
        if self.host:
            self.host.deactive()
        event.accept()
                
class CenterRulerPlugin(pya.Plugin):
    def __init__(self, view):
        super(CenterRulerPlugin, self).__init__()
        self.ctrlDock       = None
        self.marks          = []
        self.activeMarkers  = []
        self.ruler          = None
        self.rulerPts       = None
        self.circumfRuler   = None
        
        self.start_point    = None
        self.view           = view
        self.searchSize     = 1.0
        
        self.showCircumf    = False
        self.selectedObjBox = None
        self.withSelected   = False     

        self.rulerOutline   = pya.Annotation.OutlineDiagXY
        self.rulerStyle     = pya.Annotation.StyleLine
        
    def selectedAnnotationBox(self):
        unit           = self.view.active_cellview().layout().dbu
        selectedAnts   = [a for a in self.view.each_annotation_selected()]
        selectedObjBox = None
        if len(selectedAnts) == 1:
            a = selectedAnts[0]
            selectedObjBox = a.box()
        return selectedObjBox
        
    def selectedObjectBox(self):
        unit           = self.view.active_cellview().layout().dbu
        selectedObjs   = [o for o in self.view.each_object_selected()]
        selectedObjBox = None
        if len(selectedObjs) == 1:
            o = selectedObjs[0]
            if not(o.is_cell_inst()):
                if not(o.shape.is_text()): 
                    selectedObjBox = o.shape.polygon.transformed(o.trans()).to_dtype(unit).bbox()
            else:
                selectedObjBox = o.inst().bbox().transformed(o.trans()).to_dtype(unit)
        return selectedObjBox 
        
    def validselect(self):
        self.selectedObjBox = None
        antBox = self.selectedAnnotationBox()
        objBox = self.selectedObjectBox()
        
        if sum([antBox is None, objBox is None]) == 1:
            self.selectedObjBox = objBox if (antBox is None) else antBox

        self.withSelected = not(self.selectedObjBox is None)

              
    def activated(self):
        self.validselect()
        if self.withSelected:
            if not(self.ctrlDock):
                mw   = pya.Application.instance().main_window()
                self.ctrlDock = CenterRulerSetupDock()
                mw.addDockWidget(pya.Qt_DockWidgetArea.RightDockWidgetArea, self.ctrlDock)
                self.ctrlDock.setHostValue(self, self.rulerOutline, self.rulerStyle, self.searchSize, self.showCircumf)
            self.ctrlDock.show()
        
    def _clear_all(self, removeRuler = True):
        self._clear_marker()
        self._clear_normalRuler(removeRuler)
        self._clear_circumfRuler(removeRuler)
        
    def _clear_marker(self):
        for marker in self.activeMarkers:
            marker._destroy()
            
        self.marks         = []
        self.activeMarkers = []
        
    def _clear_normalRuler(self, removeRuler = True):
        if self.ruler is not None:
            if removeRuler:
                self.ruler.delete()
            self.ruler._destroy()
        self.ruler = None
        self.rulerPts      = None
        self.start_point   = None
                        
    def _clear_circumfRuler(self, removeRuler = True):
        if self.circumfRuler is not None:
            if removeRuler:
                self.circumfRuler.delete()
            self.circumfRuler._destroy()
        self.circumfRuler = None
                
    def _update_marker(self):

        if self.ruler is None:
            self.ruler = pya.Annotation()
            self.view.insert_annotation(self.ruler)
            
        self.ruler.outline = self.rulerOutline
        self.ruler.style   = self.rulerStyle
        self.ruler.points  = self.rulerPts  
                  
        if self.showCircumf:
            if self.circumfRuler is None:
                self.circumfRuler = pya.Annotation()
                self.circumfRuler.outline = pya.Annotation.OutlineDiag
                self.circumfRuler.style   = pya.Annotation.StyleLine
                self.circumfRuler.fmt     = ""
                self.view.insert_annotation(self.circumfRuler)
            self.setUpRadiusRuler(self.rulerPts[0], self.rulerPts[1], self.circumfRuler)
        else:
            if not(self.circumfRuler is None):
                self._clear_circumfRuler(True)
            
                        
        for marker in self.activeMarkers:
            marker._destroy()
        self.activeMarkers = []
            
        for mkDict in self.marks:
            marker = pya.Marker(self.view)
            data   = mkDict["mark"]
            mkType = mkDict["type"]

            marker.set(data)
            marker.line_style  = 0 
            marker.vertex_size = 0  
            
            if mkType == "vertex":
                marker.vertex_size = 12 
                
            if mkType == "edge":
                marker.vertex_size = 6  
                
            if mkType == "cursor":
                marker.line_style = 1 
                
            self.activeMarkers.append(marker)

    def setUpRadiusRuler(self, pCenter, pCurser, cRuler):
        count   = 128
        da      = 2 * math.pi / count 
        center  = pya.DVector(pCenter)
        vCursor = pya.DVector(pCurser)-pya.DVector(pCenter)
        radius  = vCursor.length()
        
        offset = 0
        if vCursor.x == 0:
            offset = math.pi / 2 * ( 1 if vCursor.y &gt;= 0 else -1) 
        else:
            offset = math.atan(vCursor.y/vCursor.x)

        cRuler.points = [center + pya.DPoint( radius * math.cos(offset+da * i), radius * math.sin(offset+da * i)) for i in range(count + 1)]
    
    def deactivated(self):
        self.ungrab_mouse()
        if (self.ctrlDock):
            self.ctrlDock.hide()
            
    def deactive(self):
        self._clear_all()
        esc_key  = 16777216 
        keyPress = pya.QKeyEvent(pya.QKeyEvent.KeyPress, esc_key, pya.Qt.NoModifier)
        pya.QApplication.sendEvent(self.view.widget(), keyPress)  
        
    def mouse_click_event(self, p, buttons, prio):
        if prio:

            if buttons == 8:
                self._clear_all(False)
                self.ungrab_mouse()
            else:
                self.deactive()             

            return True
        return False
    

    
    def mouse_moved_event(self, p, buttons, prio):
        if prio :
            if  not(self.withSelected) :
                tip = '\n\tSelect one Shape, Cell, Path or Ruler before activate plugin\t\n\tText object is currently not supported\t\n'
                pya.QToolTip().showText( pya.QCursor.pos, tip) 
                self.deactive()
                return True
                
            if self.ruler is None:
                center           = self.selectedObjBox.center()
                self.rulerPts    = [center, center]
                self.start_point = center.dup()
                self._update_marker()
                self.grab_mouse()
                
            else:
                self.set_cursor(pya.Cursor.Cross)
                cellView         = self.view.active_cellview()
                unit             = cellView.layout().dbu
                cell             = cellView.cell
                minDistance      = self.searchSize
                hoverShapes      = self.shapeInRange(p, self.searchSize)
                centerShapes     = sorted(hoverShapes, key = lambda hoveredShape: hoveredShape.bbox().center().distance(p))[0:10]
                self.marks       = list(chain.from_iterable([self.centerMark(centerShape) for centerShape in centerShapes]))
                self.rulerPts    = [self.start_point, p]
                hlVertex         = None
                hlEdge           = None
                snapPoint        = p
                
                for hoveredShape in hoverShapes:
                       
                    for e in hoveredShape.each_edge():
                        if self.edgeInRange(p, e, self.searchSize):
                            epDistance  = e.distance_abs(p)
                            pp1Distance = e.p1.distance(p)
                            pp2Distance = e.p2.distance(p)
                            
                            if epDistance &lt;= minDistance:
                                minDistance = epDistance
                                snapPoint   = self.snapPoint(p, e)
                                hlEdge      = e
                                
                                ppDistance = min([pp1Distance, pp2Distance])
                                hlVertex   = None
                                if (ppDistance &lt; (minDistance * 2)):
                                    v = e.p1 if (pp1Distance &lt; pp2Distance) else e.p2
                                    if self.vertexInRange(p, v, self.searchSize):
                                        snapPoint   = self.snapPoint(p, v)
                                        hlVertex    = v

                    center = hoveredShape.bbox().center()
                    if self.vertexInRange(p, center, self.searchSize):
                        cpDistance = center.distance(p)
                        if (cpDistance &lt; (minDistance * 2)):
                            snapPoint = self.snapPoint(p, center)
                            hlVertex  = center
                            
                self.rulerPts = [self.start_point, snapPoint]
                
                if hlVertex:
                    self.marks.append(self.vertexMark(hlVertex))     
                     
                if hlEdge:
                    self.marks.append(self.edgeMark(hlEdge))                                                        
         
                self.marks.append(self.cursorMark(p, self.searchSize))
                self._update_marker()

            return True
        return False
        
    def cursorMark(self, p, detectRange):
        offset = pya.DVector(detectRange, detectRange)
        return {
            "mark" : pya.DBox(p - offset, p + offset), 
            "type" : "cursor"
        }   
             
    def centerMark(self, shape):
        b  = shape.bbox()
        c  = b.center()
        r  = min([b.width(), b.height()]) * 0.1
        vx = pya.DVector(r, 0)
        vy = pya.DVector(0, r)
        return [{
            "mark" : pya.DEdge(c + vy, c - vy), 
            "type" : "center"
        },{
            "mark" : pya.DEdge(c + vx, c - vx), 
            "type" : "center"
        }]
        
    def edgeMark(self, edge):
        return {
            "mark" : edge, 
            "type" : "edge"
        }
        
    def vertexMark(self, vertex):
        return {
            "mark" : pya.DEdge(vertex, vertex), 
            "type" : "vertex"
        }    
        
    def vertexInRange(self, point, vertex, detectRange):
        #offset     = pya.DVector(detectRange, detectRange)
        #detectArea = pya.DBox(vertex - offset, vertex + offset )
        #detected   =  detectArea.contains(point)
        inXRange   = (vertex.x - detectRange) &lt;= point.x &lt;= (vertex.x + detectRange)
        inYRange   = (vertex.y - detectRange) &lt;= point.y &lt;= (vertex.y + detectRange)
        detected   = all([inXRange, inYRange])
        return detected
        
    def edgeInRange(self, point, edge, detectRange):
        detectArea = pya.DPath([edge.p1, edge.p2], detectRange * 2).simple_polygon()
        detected   = detectArea.inside(point)
        #inXRange   = (edge.p1.x - detectRange) &lt;= point.x &lt;= (edge.p2.x + detectRange)
        #inYRange   = (edge.p1.y - detectRange) &lt;= point.y &lt;= (edge.p2.y + detectRange)
        #inDRange   = edge.distance_abs(point)  &lt;= detectRange
        #detected   = all([inXRange, inYRange, inDRange])
        return detected
    
    def shapeInRange(self, point, detectRange):
        result        = []
        cellView      = self.view.active_cellview()
        layout        = cellView.layout()
        unit          = layout.dbu
        cell          = cellView.cell
        visibleLayers = [layerProp.layer_index() for layerProp in self.view.each_layer() if (layerProp.visible and layerProp.layer_index() &gt;= 0)]
        rngVector     = pya.DVector(detectRange, detectRange)
        searchBox     = pya.DBox(point - rngVector, point + rngVector)
        
        for li in visibleLayers:
            for o in cell.begin_shapes_rec_touching(li, searchBox):
                if not(o.shape().is_text()):
                    result.append(o.shape().polygon.transformed(o.trans()).to_dtype(unit))
        return result
        
    def snapPoint(self, point, edge_point): 
        if isinstance(edge_point, pya.DEdge):
            edge = edge_point
            dx   = edge.p2.x - edge.p1.x 
            dy   = edge.p2.y - edge.p1.y 
            if dx == 0:
                return pya.DPoint(edge.p1.x, point.y)
            if dy == 0:
                return pya.DPoint(point.x, edge.p1.y)
            else:
                return pya.DPoint(point.x,(point.x - edge.p1.x)/dx * dy + edge.p1.y)
        if isinstance(edge_point, pya.DPoint):
            return edge_point       
        return None
                
                


class CenterRulerPluginFactory(pya.PluginFactory):
    def __init__(self):
        super(CenterRulerPluginFactory, self).__init__()
        iconPath = str(os.path.dirname(__file__)) + "/CenterRulerIcon/%s.png"
        self.register(-1000, "Center Ruler", "Center Ruler", iconPath % "icon")

    def create_plugin(self, manager, root, view):
        return CenterRulerPlugin(view)

CenterRulerPluginFactory.instance = CenterRulerPluginFactory()
</text>
</klayout-macro>
